#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - HARDWARE - Display                                                         #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
substitutions:
  BOOT_STEP_HW_DISPLAY: '1UL << 5'

api:
  id: !extend api_server
  actions:
    # Sends custom commands directly to the display for dynamic interactions and updates.
    - action: command
      variables:
        cmd: string  # Command string to be sent. Refer to the Nextion Instruction Set for supported commands: https://nextion.tech/instruction-set/
      then:
        - lambda: |-
            send_command->execute(cmd.c_str());

    # Changes the foreground color of a specified component on the display.
    - action: component_color
      variables:
        page: string       # Page name
        component: string  # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
        color: int[]       # New color for the component, specified as an RGB array (e.g., [255, 0, 0] for red).
      then:
        - lambda: |-
            if (color.size() == 3)
              set_component_font_color->execute(page.c_str(), component.c_str(),
                                                (((color[0] & 0xF8) << 8) | ((color[1] & 0xFC) << 3) |(color[2] >> 3)));

    # Updates the text of a specified component on the display.
    - action: component_text
      variables:
        page: string       # Page name
        component: string  # Identifier of the component. Ensure it matches the component's ID in your display layout.
        txt: string        # New text content to be displayed. Supports both static and dynamic content.
      then:
        - script.execute:
            id: set_component_text
            page: !lambda return page;
            component: !lambda return component;
            text: !lambda return txt;

    # Updates the value of a specified component on the display.
    - action: component_val
      variables:
        page: string       # Page where the component is located
        component: string  # Identifier of the component to update. Must match the component's ID in the display layout.
        val: int           # New integer value to set for the component. Adjust based on the data type you're displaying.
      then:
        - script.execute:
            id: set_component_value
            page: !lambda return page;
            component: !lambda return component;
            val: !lambda return val;

    # Hides or shows a specified component on the display.
    - action: component_visibility
      variables:
        page: string       # Page where the component is located
        component: string  # Identifier of the component to be hidden/shown. Ensure this matches the component's ID in your display layout.
        show: bool         # Set to true to show the component, or false to hide it.
      then:
        - script.execute:
            id: set_component_visibility
            page: !lambda return page;
            component: !lambda return component;
            show: !lambda return show;

    # Displays detailed information for a specific entity.
    - action: entity_details_show
      variables:
        entity_id: string  # The ID of the entity for which details are shown. Supports "embedded_climate" for built-in climate control.
        back_page: string  # Specifies the page to return to. Accepts "home" or "buttonpage01" to "buttonpage04".
      then:
        - lambda: |-
            if (not entity_id.empty() and not back_page.empty()) {
              size_t dotPos = entity_id.find(".");
              std::string domain;  // The domain part of the entity, like "light" or "switch".
              std::string id;
              if (dotPos != std::string::npos) {
                // Extract domain and id from the entity_id string
                domain = entity_id.substr(0, dotPos);
                id = entity_id.substr(dotPos + 1);
              } else {
                // No dot found, the entire entity_id is considered as id.
                domain = "invalid";
                id = entity_id;
              }
              if (entity_id == "embedded_climate" or domain != "invalid") {
                detailed_entity->publish_state(entity_id.c_str());
                std::string new_page = (entity_id == "embedded_climate" ? "climate" :
                                        (domain == "alarm_control_panel" ? "alarm" : domain));
                goto_page_id->execute(get_page_id(new_page.c_str()), true);
                set_variable_value->execute("back_page_id", get_page_id(back_page.c_str()));
                if (new_page == "climate")
                  set_component_value->execute("climate", "embedded", entity_id == "embedded_climate" ? 1 : 0);
              }
            }

    # Icon action
    - action: icon
      variables:
        page: string       # Page name
        component: string  # Identifier of the component. See "Screen components" in the documentation.
        icon: string       # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
        color: int[]       # RGB color array for the icon, e.g., [0, 255, 0] for green.
        font: int          # font size for icon
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - lambda: |-
            ESP_LOGD("api.actions.icon", "New value for icon %s on page %s", component.c_str(), page.c_str());
            if (not page.empty() and not component.empty()) {
              icon_action->execute(page.c_str(), component.c_str(), icon.c_str(), color, font, visible);
            }

    # Text action
    - action: text
      variables:
        page: string       # Page name
        component: string  # Identifier of the component. See "Screen components" in the documentation.
        txt: string        # The text to display
        color: int[]       # RGB color array for the text, e.g., [0, 255, 0] for green.
        font: int          # font size for text
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - lambda: |-
            ESP_LOGD("api.actions.text", "New value for text %s on page %s", component.c_str(), page.c_str());
            if (not page.empty() and not component.empty()) {
              text_action->execute(page.c_str(), component.c_str(), txt.c_str(), color, font, visible);
            }

    # Updates an entity to display specific values with dynamic icons, names, and color codes.
    - action: value
      variables:
        page: string        # Page name
        component: string   # Identifier of the entity. See "Screen components" for entity IDs.
        icon: string        # Icon codepoint (e.g., "/uE6E8" for mdi:thermometer) from HASwitchPlate Material Design Icons.
        icon_color: int[]   # RGB color array for the icon (e.g., [255, 0, 0] for red).
        name: string        # Display name for the entity (e.g., "Temperature").
        value: string       # Actual value to display (e.g., "75Â°F").
        value_color: int[]  # RGB color array for the value text (e.g., [255, 255, 0] for yellow).
      then:
        - lambda: |-
            if (not component.empty()) {
              if (not icon.empty())
                set_component_text->execute(page.c_str(), (component + "_icon").c_str(), icon.c_str());
              if (icon_color.size() == 3)
                set_component_font_color->execute(page.c_str(), (component + "_icon").c_str(),
                                                  (((icon_color[0] & 0xF8) << 8) | ((icon_color[1] & 0xFC) << 3) | (icon_color[2] >> 3)));
              if (not name.empty())
                set_component_text->execute(page.c_str(), (component + "_label").c_str(), name.c_str());
              if (not value.empty())
                set_component_text->execute(page.c_str(), component.c_str(),
                                            adjustDecimalSeparator(value, id(mui_decimal_separator)).c_str());
              if (value_color.size() == 3)
                set_component_font_color->execute(page.c_str(), component.c_str(),
                                                  (((value_color[0] & 0xF8) << 8) | ((value_color[1] & 0xFC) << 3) | (value_color[2] >> 3)));
            }

binary_sensor:
  ## Delays initial info from HA to the display #####
  - name: Nextion display
    id: nextion_init
    platform: template
    device_class: connectivity
    publish_initial_state: true
    entity_category: diagnostic
    icon: mdi:tablet-dashboard
    lambda: return disp1->is_setup();

display:
  - id: disp1
    platform: nextion
    uart_id: tf_uart

    on_buffer_overflow:
      then:
        - script.execute: nextion_queue_delay_factor_increment

    on_page:
      then:
        - lambda: page_changed->execute(x);

    on_setup:
      then:
        - lambda: |-
            page_changed->execute(${PAGE_ID_BOOT});
            // Set the current baud rate into the display
            disp1->send_command_printf("bauds=%" PRIu32, tf_uart->get_baud_rate());
    # Extended by:
    # - nspanel_esphome_core_boot.yaml

    on_touch:
      then:
      # Extended by
      # - nspanel_esphome_core_display_timers.yaml
      # - nspanel_esphome_core_page_climate.yaml
      # - nspanel_esphome_core_page_fan.yaml
      # - nspanel_esphome_core_page_light.yaml
      # - nspanel_esphome_core_page_notification.yaml
      # - nspanel_esphome_core_page_settings.yaml
      # - nspanel_esphome_core_page_weather.yaml
      # - nspanel_esphome_core_version.yaml

esphome:
  on_boot:
    - priority: 1000.5
      then:
        - lambda: setup_icons();

    - priority: 600.5
      then:
        - wait_until:
            - lambda: return not id(is_safe_mode);
        - wait_until:
            condition:
              - lambda: return (not isnan(stoi(baud_rate->state)));
            timeout: 60s
        - script.execute:
            id: boot_log
            category: on_boot
            log_message: Set baud rate
        - lambda: |-
            if (stoi(baud_rate->state) != tf_uart->get_baud_rate())
              set_baud_rate->execute(stoi(baud_rate->state), true);
        - wait_until:
            condition:
              - lambda: return disp1->is_setup();
            timeout: 60s
        - if:
            condition:
              - lambda: return (not disp1->is_detected());
            then:
              - script.execute:
                  id: boot_log
                  category: on_boot
                  log_message: Restart Nextion
              - switch.turn_off: screen_power
              - delay: 2s
              - switch.turn_on: screen_power

  on_shutdown:
    - priority: 600.5
      then:
        - switch.turn_off: screen_power
    - priority: 0.5
      then:
        - binary_sensor.template.publish:  # Make it unavailable to blueprint calls
            id: nextion_init
            state: false

external_components:  # Remove this when PR#7772 is merged
  - source:
      type: git
      url: https://github.com/edwardtfn/esphome
      ref: nextion-on-buffer-overflow
    refresh: 30s
    components:
      - nextion

globals:
  - id: display_charset
    type: uint8_t
    restore_value: false
    initial_value: '0'  # Charset (1 = International (original), 2 = CJK languages)

  - id: display_mode
    type: uint8_t
    restore_value: false
    initial_value: '0'  # 1 = EU, 2 = US, 3 = US landscape, 4 = blank, 5 = US landscape (inverted)

  - id: current_page_id
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: previous_page_id
    type: uint8_t
    restore_value: false
    initial_value: '0'

  - id: mui_bytes_per_char
    type: uint8_t
    restore_value: true
    initial_value: '1'

  - id: mui_decimal_separator
    type: char
    restore_value: true
    initial_value: "'.'"

  - id: nextion_queue
    type: uint8_t
    restore_value: false
    initial_value: '0'

json:  # Can be replaced by web_server

number:
  - id: display_brightness  # SCREEN BRIGHTNESS
    name: Brightness - Normal
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 100
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            set_variable_value->execute("brightness", static_cast<uint8_t>(x));
      # Extended by:
      #   - nspanel_esphome_core_hw_display_timers.yaml

  - id: display_dim_brightness  # SCREEN BRIGHTNESS DIMMED DOWN
    name: Brightness - Dimmed
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 25
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            set_variable_value->execute("brightness_dim", static_cast<uint8_t>(x));
            if (id(current_page_id) != ${PAGE_ID_SCREENSAVER} and current_brightness->state != x)
              set_brightness->execute(static_cast<uint8_t>(x));

  - id: display_sleep_brightness  # SCREEN BRIGHTNESS SLEEP
    name: Brightness - Sleep
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 0
    max_value: 100
    initial_value: 0
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - script.execute:
            id: set_variable_value
            variable: brightness_sleep
            val: !lambda return static_cast<uint8_t>(x);
        - script.execute: page_screensaver

  - id: nextion_queue_delay_factor
    name: Display queue delay factor
    platform: template
    entity_category: config
    min_value: 0
    max_value: 25
    initial_value: 0
    step: 1
    restore_value: true
    optimistic: true
    internal: false
    disabled_by_default: true

script:
  - id: !extend boot_progress_dump
    then:
      - lambda: |-
          boot_progress_dump_item->execute(${BOOT_STEP_HW_DISPLAY}, "HW Display");

  - id: display_wrapped_text
    mode: queued
    max_runs: 15
    parameters:
      page: string
      component: string
      text_to_display: string
      line_length_limit: uint
    then:
      - lambda: |-
          int startPos = 0;
          int endPos = 0;
          std::string wrappedText = "";
          if (text_to_display.find("\\r") != std::string::npos) {
            wrappedText = text_to_display;
          } else {
            while (startPos < text_to_display.length()) {
              while (text_to_display[startPos] == ' ' and startPos < text_to_display.length()) { startPos++; }
              int endPos = startPos + (line_length_limit * id(mui_bytes_per_char));
              if (endPos >= text_to_display.length()) endPos = text_to_display.length();
              else
                {
                  while (endPos > startPos && text_to_display[endPos] != ' ') { endPos--; }
                  if (endPos == startPos) endPos = startPos + (line_length_limit * id(mui_bytes_per_char)); // Handle case of long word
                }
              wrappedText += text_to_display.substr(startPos, endPos-startPos);
              if (endPos < text_to_display.length())
                {
                  while (text_to_display[endPos] == ' ') { endPos--; }
                  if (endPos >= startPos) wrappedText += "\\r";
                }
              startPos = endPos + 1; // Skip the space
              while (text_to_display[startPos] == ' ' and startPos < text_to_display.length()) { startPos++; }
            }
          }
          set_component_text->execute(page.c_str(), component.c_str(), wrappedText.c_str());

  - id: !extend dump_config
    then:
      - lambda: |-
          static const char *const TAG = "${project_tag}";
          // Report UART
          ESP_LOGCONFIG(TAG, "UART:");
          ESP_LOGCONFIG(TAG, "  Baud rate:    %" PRIu32 " bps", tf_uart->get_baud_rate());
          ESP_LOGCONFIG(TAG, "  Queue size:   %d", tf_uart->available());

          // Report Nextion status
          nextion_init->publish_state(nextion_init->state and disp1->is_setup());
          ESP_LOGCONFIG(TAG, "Nextion:");
          ESP_LOGCONFIG(TAG, "  Delay factor: %" PRIu8, static_cast<uint8_t>(nextion_queue_delay_factor->state));
          ESP_LOGCONFIG(TAG, "  Queue size:   %d", disp1->queue_size());
          if (disp1->is_setup())
            ESP_LOGCONFIG(TAG, "  Is setup:     True");
          else {
            ESP_LOGW(TAG, "  Is setup:     False");
            ESP_LOGW(TAG, "  Is detected:  %s", YESNO(disp1->is_detected()));
            //exit_reparse->execute();
          }
          if (nextion_init->state) {
            ESP_LOGCONFIG(TAG, "  Init:         True");
          } else
            ESP_LOGW(TAG, "  Init:         False");
          if (id(version_tft).empty())
            ESP_LOGW(TAG, "  TFT:          UNKNOWN");
          else
            ESP_LOGCONFIG(TAG, "  TFT:          %s", id(version_tft).c_str());

  - id: event_from_display
    mode: parallel
    parameters:
      json: DynamicJsonDocument
      page: string
    then:
      - lambda: |-
          static const char *const TAG = "script.event_from_display";
          const std::string event = json["event"];
          const std::string component = json["component"];
          const std::string value = json["value"];
          // Send event to Home Assistant
          esphome::api::CustomAPIDevice ha_event;
          if (event == "short_click" or event == "long_click") {
            // Button click event
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
              {"device_name", device_name->state.c_str()},
              {"esphome_version", "${version}"},
              {"type", "button_click"},
              {"page", page.c_str()},
              {"component", component.c_str()},
              {"command", event.c_str()}
            });
          } else if (event == "params") {
              ESP_LOGI(TAG, "Display parameters received:");
              id(display_mode) = json["display_mode"].as<uint8_t>();
              id(display_charset) = json["charset"].as<uint8_t>();
              ESP_LOGI(TAG, "  Display mode:    %" PRIu8, id(display_mode));
              ESP_LOGI(TAG, "  Display charset: %" PRIu8, id(display_charset));
              send_command->execute("tm_esphome.en=0");
              boot_progress->execute(${BOOT_STEP_HW_DISPLAY}, "HW Display");
          } else {
            // Generic event
            ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
              {"device_name", device_name->state.c_str()},
              {"esphome_version", "${version}"},
              {"type", "button_click"},
              {"page", page.c_str()},
              {"component", component.c_str()},
              {"event", event.c_str()},
              {"value", value.c_str()},
              {"entity", detailed_entity->state.c_str()}
            });
          }

      # Extended by:
      #   - nspanel_esphome_core_page_alarm.yaml
      #   - nspanel_esphome_core_page_climate.yaml
      #   - nspanel_esphome_core_page_cover.yaml
      #   - nspanel_esphome_core_page_fan.yaml
      #   - nspanel_esphome_core_page_keyb_num.yaml
      #   - nspanel_esphome_core_page_light.yaml
      #   - nspanel_esphome_core_page_media_player.yaml
      #   - nspanel_esphome_core_versioning.yaml

  - id: goto_page_id
    mode: restart
    parameters:
      page_id: uint8_t
      reset_timers: bool
    then:
      - lambda: disp1->goto_page(page_id);
      # Extended by:
      #   - nspanel_esphome_core_hw_display_timers.yaml

  - id: icon_action
    mode: parallel
    parameters:
      page: string           # Page name
      component: string      # Identifier of the component. See "Screen components" in the documentation.
      icon: string           # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
      color: int32_t[]  # RGB color array for the icon, e.g., [0, 255, 0] for green.
      font: int         # font size for icon
      visible: bool          # Set to `true` for visible or `false` for hidden.
    then:
      # Extended by:
      #   nspanel_esphome_core_hw_relays.yaml
      - lambda: |-
              PageIcon* new_icon = get_icon(page.c_str(), component.c_str());

              const bool initializing = not new_icon->initiated;
              new_icon->initiated = true;

              const bool changed_visibility = (new_icon->visible != visible);

              // Icon codepoint
              if (!icon.empty() and (initializing or changed_visibility or icon != new_icon->icon)) {
                copyStringToCharArray(new_icon->icon, icon);
                if (current_page->state == page)
                  icon_set_icon->execute(new_icon);
                }

              // Icon color
              if (color.size() == 3 and
                  color[0] >= 0 and color[0] <= UINT8_MAX and
                  color[1] >= 0 and color[1] <= UINT8_MAX and
                  color[2] >= 0 and color[2] <= UINT8_MAX) {
                uint16_t new_icon_color = color565(color);
                if (initializing or changed_visibility or new_icon->icon_color != new_icon_color) {
                  new_icon->icon_color = new_icon_color;
                  if (current_page->state == page)
                    icon_set_color->execute(new_icon);
                }
              }

              // Icon font
              if (font >= 0 and font <= UINT8_MAX and
                  (initializing or changed_visibility or new_icon->icon_font != font)) {
                new_icon->icon_font = font;
                if (current_page->state == page)
                  icon_set_font->execute(new_icon);
              }

              // Icon visibility
              if (initializing or changed_visibility) {
                new_icon->visible = visible;
                if (current_page->state == page)
                  icon_set_visibility->execute(new_icon);
              }

  - id: icon_set
    mode: parallel
    parameters:
      icon: PageIcon*
    then:
      - lambda: |-
          ESP_LOGD("script.icon_set", "Rendering page %s, component %s", icon->page, icon->component);
          icon_set_icon->execute(icon);
          icon_set_color->execute(icon);
          icon_set_font->execute(icon);
          icon_set_visibility->execute(icon);

  - id: icon_set_color
    mode: parallel
    parameters:
      icon: PageIcon*
    then:
      - lambda: |-
          set_component_font_color->execute(icon->page, icon->component, icon->icon_color);

  - id: icon_set_font
    mode: parallel
    parameters:
      icon: PageIcon*
    then:
      - lambda: |-
          if (icon->icon_font != UINT8_MAX)
            set_component_font->execute(icon->page, icon->component, icon->icon_font);

  - id: icon_set_icon
    mode: parallel
    parameters:
      icon: PageIcon*
    then:
      - lambda: |-
          set_component_text->execute(icon->page, icon->component, icon->icon);

  - id: icon_set_visibility
    mode: parallel
    parameters:
      icon: PageIcon*
    then:
      - lambda: |-
          set_component_visibility->execute(icon->page, icon->component, icon->visible);

  - id: nextion_queue_add
    mode: queued
    then:
      - lambda: |-
          id(nextion_queue)++;
          if (id(nextion_queue) > 128)
            nextion_queue_reset->execute();

  - id: nextion_queue_del
    mode: queued
    then:
      - lambda: |-
          if (id(nextion_queue) > 0)
            id(nextion_queue)--;

  - id: nextion_queue_delay_factor_increment
    mode: restart
    then:
      - delay: 15s
      - lambda: |-
          ESP_LOGE("script.nextion_queue_delay_factor_increment", "Nextion reported a buffer overflow");
          ESP_LOGE("script.nextion_queue_delay_factor_increment", "Increasing the delay factor...");
      - number.increment:
          id: nextion_queue_delay_factor
          cycle: false

  - id: nextion_queue_reset
    mode: restart
    then:
      - lambda: |-
          set_component_font->stop();
          set_component_font_color->stop();
          set_component_pic->stop();
          set_component_picc->stop();
          set_component_text->stop();
          set_component_value->stop();
          set_component_visibility->stop();
          id(nextion_queue) = 0;

  - id: page_changed
    parameters:
      new_page_id: uint8_t
    mode: restart
    then:
      # This is extended by most of the page's yaml files.
      - lambda: |-
            const bool is_new_page = (new_page_id != id(current_page_id));
            if (is_new_page) {
              id(previous_page_id) = id(current_page_id);
              id(current_page_id) = new_page_id;
              current_page->publish_state(page_names[id(current_page_id)]);
            }
            if (is_new_page or new_page_id == ${PAGE_ID_BOOT}) {
              // Report new page to logs
              ESP_LOGI("display.disp1.on_page", "Page changed from \"%s\" to \"%s\"", page_names[id(previous_page_id)],
                        page_names[new_page_id]);

              // Clear the buffer when a new page opens
              nextion_queue_reset->execute();

              // Reset entity_id when it does not apply
              if (new_page_id != ${PAGE_ID_ALARM} and
                  new_page_id != ${PAGE_ID_CLIMATE} and
                  new_page_id != ${PAGE_ID_COVER} and
                  new_page_id != ${PAGE_ID_FAN} and
                  new_page_id != ${PAGE_ID_LIGHT} and
                  new_page_id != ${PAGE_ID_MEDIA_PLAYER} and
                  new_page_id != ${PAGE_ID_CONFIRM} and
                  new_page_id != ${PAGE_ID_KEYB_NUM}) {
                detailed_entity->publish_state("");
                set_variable_value->execute("back_page_id", ${PAGE_ID_HOME});
              }

              // Inform Home Assistant about the page change
              esphome::api::CustomAPIDevice ha_event;
              ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "page_changed"},
                {"page", page_names[new_page_id]},
                {"from", page_names[id(previous_page_id)]},
                {"entity", detailed_entity->state.c_str()}
              });
            }
            page_changed_rendering_texts->execute();
            page_changed_rendering_icons->execute();

  - id: page_changed_rendering_icons
    mode: restart
    then:
      - lambda: |-
          // Plot page's icons
          std::vector<PageIcon*> page_icons = list_icons_by_page(page_names[id(current_page_id)]);
          for (PageIcon* icon : page_icons) {
              icon_set->execute(icon);
          }

  - id: page_changed_rendering_texts
    mode: restart
    then:
      - lambda: |-
          // Plot page's texts
          std::vector<PageText*> page_texts = list_texts_by_page(page_names[id(current_page_id)]);
          for (PageText* txt : page_texts) {
              text_set->execute(txt);
          }

  - id: send_command
    mode: queued
    parameters:
      cmd: string
    then:
      - lambda: |-
          nextion_queue_add->execute();
          disp1->send_command(cmd.c_str());
          nextion_queue_del->execute();

  - id: set_baud_rate
    mode: restart
    parameters:
      baud_rate: uint32_t
      definitive: bool
    then:
      - if:
          condition:
            - lambda: return (tf_uart->get_baud_rate() != baud_rate);
          then:
            - lambda: |-
                ESP_LOGI("script.set_baud_rate", "Baud rate changing from %" PRIu32 " to %" PRIu32 " bps", tf_uart->get_baud_rate(), baud_rate);
                ESP_LOGD("script.set_baud_rate", "Flush UART");
            - wait_until:
                condition:
                  - lambda: return (tf_uart->available() < 1);
                timeout: 5s
            - lambda: |-
                ESP_LOGD("script.set_baud_rate", "Sending instruction '%s=%" PRIu32 "' to Nextion", definitive ? "bauds" : "baud", baud_rate);
                disp1->send_command_printf("%s=%" PRIu32, definitive ? "bauds" : "baud", baud_rate);
                ESP_LOGD("script.set_baud_rate", "Flush UART");
            - wait_until:
                condition:
                  - lambda: return (tf_uart->available() < 1);
                timeout: 5s
            - lambda: |-
                ESP_LOGD("script.set_baud_rate", "Set ESPHome new baud rate to %" PRIu32 " bps", baud_rate);
                tf_uart->set_baud_rate(baud_rate);
                tf_uart->load_settings();
                ESP_LOGI("script.set_baud_rate", "Current baud rate: %" PRIu32 " bps", tf_uart->get_baud_rate());

  - id: set_brightness
    mode: restart
    parameters:
      brightness: uint8_t
    then:
      - lambda: |-
          nextion_queue_add->execute();
          disp1->set_backlight_brightness(brightness / 100.0f);
          current_brightness->update();
          nextion_queue_del->execute();

  - id: set_component_font
    mode: parallel
    parameters:
      page: string
      component: string
      font: uint8_t
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          disp1->set_component_font(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), font);
          nextion_queue_del->execute();

  - id: set_component_font_color
    mode: parallel
    parameters:
      page: string
      component: string
      color: uint16_t
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          if (page == "home" or page == current_page->state)
            disp1->set_component_font_color(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), color);
          nextion_queue_del->execute();

  - id: set_component_picc
    mode: parallel
    parameters:
      page: string
      component: string
      picc: uint8_t
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          if (page == "home" or page == current_page->state)
            disp1->set_component_picc(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), picc);
          nextion_queue_del->execute();

  - id: set_component_foreground_color
    mode: parallel
    parameters:
      page: string
      component: string
      color: int
    then:
      - lambda: set_component_font_color->execute(page.c_str(), component.c_str(), color);

  - id: set_component_pic
    mode: parallel
    parameters:
      page: string
      component: string
      pic: uint8_t
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          if (page == "home" or page == current_page->state)
            disp1->set_component_pic(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), pic);
          nextion_queue_del->execute();

  - id: set_component_text
    mode: parallel
    parameters:
      page: string
      component: string
      text: string
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          if (page == "home" or page == current_page->state)
            disp1->set_component_text(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), text.c_str());
          nextion_queue_del->execute();

  - id: set_component_value
    mode: parallel
    parameters:
      page: string
      component: string
      val: int
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          if (page == "home" or page == current_page->state)
            disp1->set_component_value(current_page->state == page ? component.c_str() : (page + "." + component).c_str(), val);
          nextion_queue_del->execute();

  - id: set_component_visibility
    mode: parallel
    parameters:
      page: string
      component: string
      show: bool
    then:
      - script.execute: nextion_queue_add
      - wait_until:
          condition:
            - text_sensor.state:
                id: current_page
                state: !lambda return page.c_str();
          timeout: 2s
      - if:
          condition:
            - lambda: return (page == current_page->state);
          then:
            - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
            - lambda: |-
                disp1->send_command_printf("vis %s,%i", component.c_str(), show ? 1 : 0);
      - script.execute: nextion_queue_del

  - id: !extend set_var_number
    then:
      - lambda: |-
          if (component == "bytes_per_char")
            id(mui_bytes_per_char) = static_cast<uint8_t>(val);

  - id: !extend set_var_string
    then:
      - lambda: |-
          if (component == "decimal_separator" and !(val.empty()))
            id(mui_decimal_separator) = val[0];

  - id: set_variable_value
    mode: queued
    parameters:
      variable: string
      val: int
    then:
      - script.execute: nextion_queue_add
      - delay: !lambda return nextion_queue_delay_factor->state*id(nextion_queue);
      - lambda: |-
          disp1->send_command_printf("%s=%i", variable.c_str(), val);
          nextion_queue_del->execute();

  - id: !extend stop_all
    then:
      - lambda: |-
          display_wrapped_text->stop();
          event_from_display->stop();
          goto_page_id->stop();
          icon_action->stop();
          icon_set->stop();
          icon_set_color->stop();
          icon_set_font->stop();
          icon_set_icon->stop();
          icon_set_visibility->stop();
          page_changed->stop();
          page_changed_rendering_icons->stop();
          send_command->stop();
          set_baud_rate->stop();
          set_brightness->stop();
          set_component_font_color->stop();
          set_component_pic->stop();
          set_component_picc->stop();
          set_component_text->stop();
          set_component_visibility->stop();
          text_action->stop();
          text_set->stop();
          text_set_color->stop();
          text_set_font->stop();
          text_set_txt->stop();
          text_set_visibility->stop();

  - id: text_action
    mode: parallel
    parameters:
      page: string       # Page name
      component: string  # Identifier of the component. See "Screen components" in the documentation.
      txt: string        # Text to display.
      color: int32_t[]   # RGB color array for the text, e.g., [0, 255, 0] for green.
      font: int          # font size for text
      visible: bool      # Set to `true` for visible or `false` for hidden.
    then:
      # Extended by:
      #   nspanel_esphome_core_hw_relays.yaml
      - lambda: |-
              PageText* new_text = get_text(page.c_str(), component.c_str());

              const bool initializing = not new_text->initiated;
              new_text->initiated = true;

              const bool changed_visibility = (new_text->visible != visible);

              // Text
              if (!txt.empty() and (initializing or changed_visibility or txt != new_text->text)) {
                copyStringToCharArray(new_text->text, txt);
                if (current_page->state == page)
                  text_set_txt->execute(new_text);
                }

              // Text color
              if (color.size() == 3 and
                  color[0] >= 0 and color[0] <= UINT8_MAX and
                  color[1] >= 0 and color[1] <= UINT8_MAX and
                  color[2] >= 0 and color[2] <= UINT8_MAX) {
                uint16_t new_text_color = color565(color);
                if (initializing or changed_visibility or new_text->text_color != new_text_color) {
                  new_text->text_color = new_text_color;
                  if (current_page->state == page)
                    text_set_color->execute(new_text);
                }
              }

              // Text font
              if (font >= 0 and font <= UINT8_MAX and
                  (initializing or changed_visibility or new_text->text_font != font)) {
                new_text->text_font = font;
                if (current_page->state == page)
                  text_set_font->execute(new_text);
              }

              // Icon visibility
              if (initializing or changed_visibility) {
                new_text->visible = visible;
                if (current_page->state == page)
                  text_set_visibility->execute(new_text);
              }

  - id: text_set
    mode: parallel
    parameters:
      txt: PageText*
    then:
      - lambda: |-
          ESP_LOGD("script.text_set", "Rendering page %s, component %s", txt->page, txt->component);
          text_set_txt->execute(txt);
          text_set_color->execute(txt);
          text_set_font->execute(txt);
          text_set_visibility->execute(txt);

  - id: text_set_color
    mode: parallel
    parameters:
      txt: PageText*
    then:
      - lambda: |-
          set_component_font_color->execute(txt->page, txt->component, txt->text_color);

  - id: text_set_font
    mode: parallel
    parameters:
      txt: PageText*
    then:
      - lambda: |-
          if (txt->text_font != UINT8_MAX)
            set_component_font->execute(txt->page, txt->component, txt->text_font);

  - id: text_set_txt
    mode: parallel
    parameters:
      txt: PageText*
    then:
      - lambda: |-
          set_component_text->execute(txt->page, txt->component, txt->text);

  - id: text_set_visibility
    mode: parallel
    parameters:
      txt: PageText*
    then:
      - lambda: |-
          set_component_visibility->execute(txt->page, txt->component, txt->visible);

select:
  - id: baud_rate
    name: Baud rate
    platform: template
    options:
      - "2400"
      - "4800"
      - "9600"
      - "19200"
      - "31250"
      - "38400"
      - "57600"
      - "115200"
      - "230400"
      - "250000"
      - "256000"
      - "512000"
      - "921600"
    initial_option: "921600"
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    disabled_by_default: true
    icon: mdi:swap-horizontal
    on_value:
      then:
        - script.execute:
            id: set_baud_rate
            baud_rate: !lambda return stoi(x);
            definitive: true

sensor:
  - id: brightslider  # Display Brightness GET VALUE FROM NSPanel SLIDER
    name: brightness Slider
    platform: nextion
    variable_name: brightslider
    internal: true

  - id: dimslider  # Display DIM Brightness GET VALUE FROM NSPanel SLIDER
    name: dim brightness slider
    platform: nextion
    variable_name: dimslider
    internal: true

  - id: current_brightness  # Display Brightness - Current value (%)
    name: Brightness - Current
    platform: nextion
    variable_name: dim
    precision: 0
    accuracy_decimals: 0
    unit_of_measurement: "%"
    icon: mdi:brightness-percent
    internal: false
    disabled_by_default: false
    update_interval: 60s

switch:
  - name: Nextion display - Power  # DISPLAY ALWAYS ON
    platform: gpio
    id: screen_power
    entity_category: diagnostic
    pin:
      number: 4
      inverted: true
    restore_mode: ALWAYS_ON
    internal: true
    disabled_by_default: false
    on_turn_off:
      then:
        - binary_sensor.template.publish:
            id: nextion_init
            state: false

text_sensor:
  - id: current_page  # Current page name - Used by Blueprint
    name: Current Page
    platform: template
    icon: mdi:tablet-dashboard
    internal: false
    disabled_by_default: false
    filters:
      - lambda: return {page_names[id(current_page_id)]};

  - id: disp1_local_event  # NSPanel event - Execute actions from ESPHome - NO directly push to HA
    name: NSPanel local event
    platform: nextion
    nextion_id: disp1
    component_name: localevent
    internal: true
    on_value:
      then:
        - lambda: |-
            DynamicJsonDocument json(1024);
            DeserializationError error = deserializeJson(json, x.c_str());
            if (error) {
              ESP_LOGE("text_sensor.disp1_local_event", "Error parsing json: %s", x.c_str());
              ESP_LOGE("text_sensor.disp1_local_event", "Error: %s", error.c_str());
            } else {
              const std::string page = json["page"];
              event_from_display->execute(json, page.c_str());
            }

uart:  ## UART for Nextion display
  - id: tf_uart
    tx_pin: 16
    rx_pin: 17
    baud_rate: 921600
...
